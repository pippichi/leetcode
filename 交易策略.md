# 策略1

```python
#encoding:gbk
def init(Contextinfo):
    Contextinfo.rate=-1.5
    contextinfo.SH_800=contextinfo.get_sector("000906.XSHG")
    Contextinfo.set_universe(contextinfo.SH800)
    Contextinfo.accid="6000693"
    print(Contextinfo.SH800)
    stock_list=[]
    
    
def handlebar(Contextinfo):
    hisDict=Contextinfo.get_history_data(2,"1d","close","0",1,False)
    for k,v in hisDict.items():
        if v[1]-v[0]>0:
            continue
        else:
            droprate=V[1]-v[0]/v[0]*100
            if droprate<=Contextinfo.rate
                print(k,droprate)
                stock_list.append(k)
                
```

# 策略2

```python
'''

def initialize(context):
    run_daily(period, time="every_bar")
    g.security1="000007.XSHE"
    g.security2="000005.XSHE"

def period(context):
    order(g.security1,100)
    order(g.security2,100)
    '''
'''    
def initialize(context):
    run_daily(period, time="every_bar")
    g.security=["000007.XSHE","000005.XSHE"]
    

def period(context):
    for i in g.security:
        order(i,100)#每只股票买100股
'''
'''
lis1=[]
for i in range(1,101):
    lis1.append(i**2)
    print(lis1)
    '''
'''   
a = [4,2,1,9,6,5,3,8,7]
for i in range(len(a)):
  for j in range(i+1,len(a)):
      if a[j] <= a[i]:
          t=a[j]
          a[j] = a[i]
          a[i]=t
print(a)
'''
'''
t=get_index_stocks("000016.XSHG", "2018-03-01")
print(t[0])
print(t)
'''
'''
w=history(count=4, unit='5d', field="money", security_list=["000007.XSHE","000016.XSHE"])
print(w)
'''

'''
w=attribute_history(security="000001.XSHE", count=4, unit="6d", fields=["money","high","open"])

print(w)
print(w.index)#这个功能是将最后的输出格式进行转化和调整。
print(w.loc[:,["open","high"]])#选取几个作为输出
print(w.loc[["2016-05-05","2016-05-13"]])#特定日期的列表
print(w.T)#行和列互换


'''
'''
#query(表.字段).filter(筛选条件).order_by(排序方法).limit(数量上限)
#比较长的话可以分行写
q=query(valuation.code,balance.retained_profit).filter(valuation.market_cap<=100,valuation.pe_ratio>=10).order_by(valuation.market_cap.desc()).limit(10)
w=get_fundamentals(q)
print(w)
'''

'''
#获取任一股票最近5个交易日最高价的平均价,fq默认是前复权的意思，df默认为ture列表的意思。
w=history(count=5, unit="1d", field="high", security_list=["000001.XSHE"] )
avg1=sum(w.values)/5
print(avg1)
'''

'''
#生成一个list，list中为上证指数成分股中流通市值最大5个股票的代码。
t=get_index_stocks("000001.XSHG","2018-06-06")
q=query(valuation.code,valuation.circulating_market_cap).filter(valuation.code.in_(t)).order_by(valuation.circulating_market_cap.desc()).limit(5)
w=get_fundamentals(q)
print(w.code)
'''

'''
#  设定好要交易的股票数量stocksnum 
  每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
  若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
  买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。
'''
'''
def initialize(context):
    run_daily(period,time="every_bar")
    g.stocksnum=10
    #设定要交易代码的数量
    
    
def period(context):
    #每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
    security1=get_index_stocks("000001.XSHG")
    security2=get_index_stocks("399106.XSHE")
    security0=security1+security2
    q=query(valuation.code,valuation.market_cap).filter(valuation.code.in_(security0)).order_by(valuation.market_cap.asc()).limit(g.stocksnum)
    df=get_fundamentals(q)
    chilist=list(df['code'])
    #print(xiaoyu7)
    print(chilist)
    #若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
    for i in context.portfolio.positions:#股票i在持仓里面
        if i not in chilist:#如果i不在选出的池子里面，则卖出
            order_target(i,0)
    
    #买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。 
    bili=context.portfolio.available_cash/g.stocksnum
    for i in chilist:
        order_value(i,bili)
    
   ''' 
'''   
 #调整与改进
 #每period(可用设置不同的周期)，控制周期进行买票
 
def initialize(context):
    run_daily(period,time="every_bar")
    g.stocksnum=7
    g.period=6
    g.days=0
    #设定要交易代码的数量
    
    
def period(context):
    if g.days%g.period==0:#这个说明每六天余数为0时，这个程序就会执行一次
        #每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
        security1=get_index_stocks("000001.XSHG")
        security2=get_index_stocks("399106.XSHE")
        security0=security1+security2
        q=query(valuation.code,valuation.market_cap).filter(valuation.code.in_(security0)).order_by(valuation.market_cap.asc()).limit(g.stocksnum)
        df=get_fundamentals(q)
        chilist=list(df['code'])
    #print(xiaoyu7)
        print(chilist)
    #若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
        for i in context.portfolio.positions:#股票i在持仓里面
            if i not in chilist:#如果i不在选出的池子里面，则卖出
                order_target(i,0)
    
    #买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。 
        bili=context.portfolio.available_cash/g.stocksnum
        for i in chilist:
            order_value(i,bili)  

    g.days=g.days+1
   
'''  

#系统1，20日单位突破法则



#买入价格为当前资金总额的10%除以绝对波动幅度，绝对波动幅度为N乘以每变动一点后的人民币。
#头寸设有上限，单只股票不能超过20%，
#只有前次交易为亏损型的时候才为有效突破，才可以买入，
#亏损型为在10日突破法则之前，出现2N的不利波动
#止损，最新入市价格的2N处。
#推出为所有价格的10日最低点。
#后期对同行业也进行股票的仓位限制



import jqdata#导入聚宽数据库
x=[]

def initialize(context): #初始化函数
    run_daily(period, time="every_bar")#每天或每分钟执行
    set_option("use_real_price",True)#开启动态复权价格
    g.stocknum=10#股票数量设置为10只



    
def period(context):
    sec1=get_index_stocks("000001.XSHG")
    sec2=get_index_stocks("399005.XSHE")
    sec3=get_index_stocks("399006.XSHE")
    secall=sec1+sec2+sec3#全A股市场股票

    #挑选20只股票流通市值大于51亿的,市盈率大于1的,按照流通市值从小到大排序，前20的入选股票池
	up=query(valuation.code,valuation.circulating_market_cap)
        .filter(valuation.code.in_(secall),valuation.circulating_market_cap>=51,valuation.pe_ratio>=1)
        .order_by(valuation.circulating_market_cap.asc())
        .limit(g.stocknum)
```



# RSI-supl

```python
'''# 导入函数库
from jqdata import *

# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    # log.set_level('order', 'error')

    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')

    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG')
      # 开盘时运行
    run_daily(market_open, time='open', reference_security='000300.XSHG')
      # 收盘后运行
    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')

## 开盘前运行函数
def before_market_open(context):
    # 输出运行时间
    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))

    # 给微信发送消息（添加模拟交易，并绑定微信生效）
    # send_message('美好的一天~')

    # 要操作的股票：平安银行（g.为全局变量）
    g.security = '000001.XSHE'

## 开盘时运行函数
def market_open(context):
    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))
    security = g.security
    # 获取股票的收盘价
    close_data = get_bars(security, count=5, unit='1d', fields=['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.available_cash

    # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    if current_price > 1.01*MA5:
        # 记录这次买入
        log.info("价格高于均价 1%%, 买入 %s" % (security))
        # 用所有 cash 买入股票
        order_value(security, cash)
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 记录这次卖出
        log.info("价格低于均价, 卖出 %s" % (security))
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)

## 收盘后运行函数
def after_market_close(context):
    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))
    #得到当天所有成交记录
    trades = get_trades()
    for _trade in trades.values():
        log.info('成交记录：'+str(_trade))
    log.info('一天结束')
    log.info('##############################################################')'''


#导入函数库
from jqdata import *

#初始化函数，设定基准
def initialize(context):
    #沪深300作为比较基准
    set_benchmark('000300.XSHG')
    #使用复权前的真实价格
    set_option('use_real_price',True)
    # 输出内容到日志 log.info()
    log.info('初始函数全局运行一次')
    

    ##股票的相关设定##
     ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(open_tax=0, close_tax=0.01, open_commission=0.0003, close_commission=0.0003,  min_commission)cost=5, type='stock')
    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
    #开盘前运行
    run_daily(before_market_open, time='before_open',reference_security='000300.XSHG')
    #开盘中运行
    run_daily(open, time='open',reference_security='000300.XSHG')
    #开盘后运行
    run_daily(after_market_open, time='after_open',reference_security='000300.XSHG')
    
#开盘前运行函数
def before_market_open(context):
    log.info('函数运行时间（before_market_open）:'+str(context.current_dt.time()))
    #要操作的股票,g是全局变量的意思
    g.security='000001.XSHE'

#开盘时运行函数
def market_open(context):
    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))
    security=g.security
    #获取股票10日的收盘价,get_bars为获取历史数据的函数
    close_data=get_bars(security, count=10,unit='1d', fields=['close'])
    MA10=close_data[close].mean()#mean函数为取平均值的意思
    #取得上一个时间点的价格
    current_price=close_data['close'][-1]
    #取得当前现金
    cash=context.portfolio.available_cash
    
    #获得成交量
    
```

# 均线策略

```python
import jqdata#导入聚宽数据库


def initialize(context): #初始化函数
    run_daily(period, time="every_bar")#每天或每分钟执行
    set_option("use_real_price",True)#开启动态复权价格
    
    
def period(context):
    sec1=get_index_stocks("000001.XSHG")
    sec2=get_index_stocks("399005.XSHE")
    sec3=get_index_stocks("399006.XSHE")
    secall=sec1+sec2+sec3#全A股市场股票

    for i in secall:
        close_data5=attribute_history(i, 5, '1d', ['close'])#取得5日收盘价
        close_data10=attribute_history(i, 10, '1d', ['close'])#取得5日收盘价
        close_data20=attribute_history(i, 20, '1d', ['close'])#取得5日收盘价
        close_data40=attribute_history(i, 40, '1d', ['close'])#取得5日收盘价
        close_data60=attribute_history(i, 60, '1d', ['close'])#取得5日收盘价
        MA5=close_data5['close'].mean()
        MA10=close_data10['close'].mean()
        MA20=close_data20['close'].mean()
        MA40=close_data40['close'].mean()
        MA60=close_data60['close'].mean()
        
        
        #if MA5>MA10:
        #    print(i)"
            
            
    for x in secall:
        close_data5=attribute_history(x, 5, '1d', ['close'])#取得5日收盘价
        close_data10=attribute_history(x, 10, '1d', ['close'])#取得5日收盘价
        close_data20=attribute_history(x, 20, '1d', ['close'])#取得5日收盘价
        close_data40=attribute_history(x, 40, '1d', ['close'])#取得5日收盘价
        close_data60=attribute_history(x, 60, '1d', ['close'])#取得5日收盘价
        MA5=close_data5['close'].mean()
        MA10=close_data10['close'].mean()
        MA20=close_data20['close'].mean()
        MA40=close_data40['close'].mean()
        MA60=close_data60['close'].mean() 
        
        if MA5>MA10>MA20:
            print(x)

```

# 市盈率-成交量统计

```python 
from jqdata import finance

q=query(finance.STK_EXCHANGE_TRADE_INFO.pe_average).filter(finance.STK_EXCHANGE_TRADE_INFO.date>='2000-01-01',finance.STK_EXCHANGE_TRADE_INFO.exchange_code==322001).limit(3000)
df=finance.run_query(q)
print(df)
```

# 策略6

```python
# 导入函数库
import jqdata

# 初始化函数，设定要操作的股票、基准等等
def initialize(context):
    # 定义一个全局变量, 保存要操作的股票
    # 000001(股票:平安银行)
    g.security = '000001.XSHE'
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)

# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次
def handle_data(context, data):
    security = g.security
    # 获取股票的收盘价
    close_data = attribute_history(security, 5, '1d', ['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.cash

    # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    if current_price > 1.01*MA5:
        # 用所有 cash 买入股票
        order_value(security, cash)
        # 记录这次买入
        log.info("Buying %s" % (security))
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)
        # 记录这次卖出
        log.info("Selling %s" % (security))
    # 画出上一时间点价格
    record(stock_price=current_price)

```

# 策略7

```python
# 导入聚宽函数库
import jqdata

# 初始化函数，设定要操作的股票、基准等等
def initialize(context):
    # 定义一个全局变量, 保存要操作的股票
    # 000001(股票:平安银行)
    g.security = '000001.XSHE'
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 运行函数
    run_daily(market_open, time='every_bar')

# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次
def market_open(context):
    security = g.security
    # 获取股票的收盘价
    close_data = attribute_history(security, 5, '1d', ['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.cash

    # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    if current_price > 1.01*MA5:
        # 用所有 cash 买入股票
        order_value(security, cash)
        # 记录这次买入
        log.info("Buying %s" % (security))
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)
        # 记录这次卖出
        log.info("Selling %s" % (security))
    # 画出上一时间点价格
    record(stock_price=current_price)
```

# 策略8

```python
# 导入函数库
from jqdata import *

# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    # log.set_level('order', 'error')
    
    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')
    
    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') 
      # 开盘时运行
    run_daily(market_open, time='open', reference_security='000300.XSHG')
      # 收盘后运行
    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')
    
## 开盘前运行函数     
def before_market_open(context):
    # 输出运行时间
    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))

    # 给微信发送消息（添加模拟交易，并绑定微信生效）
    send_message('美好的一天~')

    # 要操作的股票：平安银行（g.为全局变量）
    g.security = '000001.XSHE'
    
## 开盘时运行函数
def market_open(context):
    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))
    security = g.security
    # 获取股票的收盘价
    close_data = attribute_history(security, 5, '1d', ['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.available_cash

    # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    if current_price > 1.01*MA5:
        # 记录这次买入
        log.info("价格高于均价 1%%, 买入 %s" % (security))
        # 用所有 cash 买入股票
        order_value(security, cash)
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 记录这次卖出
        log.info("价格低于均价, 卖出 %s" % (security))
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)
 
## 收盘后运行函数  
def after_market_close(context):
    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))
    #得到当天所有成交记录
    trades = get_trades()
    for _trade in trades.values():
        log.info('成交记录：'+str(_trade))
    log.info('一天结束')
    log.info('##############################################################')

```

# 策略9

```python
def initialize(context):
    run_daily(period, time="every_bar")
    g.security="000005.XSHE"
    
def period(context):
    h1=attribute_history(g.security,20,"1d",("high","pre_close"),skip_paused=True)
    h2=h1["pre_close"]
    print(h2)
    
```

# 策略10

```python
# 导入函数库
from jqdata import *

# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    
    # 过滤掉order系列API产生的比error级别低的log
    # log.set_level('order', 'error')
    
    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')
    
    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') 
      # 开盘时或每分钟开始时运行
    run_daily(market_open, time='every_bar', reference_security='000300.XSHG')
      # 收盘后运行
    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')
    
## 开盘前运行函数     
def before_market_open(context):
    pass
    
## 开盘时运行函数
def market_open(context):
    pass
 
## 收盘后运行函数  
def after_market_close(context):
    pass

```

# 策略11

```python
# 导入函数库
from jqdata import *

# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    # log.set_level('order', 'error')
    
    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')
    
    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') 
      # 开盘时运行
    run_daily(market_open, time='open', reference_security='000300.XSHG')
      # 收盘后运行
    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')
    
## 开盘前运行函数     
def before_market_open(context):
    # 输出运行时间
    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))

    # 给微信发送消息（添加模拟交易，并绑定微信生效）
    send_message('美好的一天~')

    # 要操作的股票：平安银行（g.为全局变量）
    g.security = '000001.XSHE'
    
## 开盘时运行函数
def market_open(context):
    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))
    security = g.security
    # 获取股票的收盘价
    close_data = attribute_history(security, 5, '1d', ['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.available_cash

    # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    if current_price > 1.01*MA5:
        # 记录这次买入
        log.info("价格高于均价 1%%, 买入 %s" % (security))
        # 用所有 cash 买入股票
        order_value(security, cash)
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 记录这次卖出
        log.info("价格低于均价, 卖出 %s" % (security))
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)
 
## 收盘后运行函数  
def after_market_close(context):
    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))
    #得到当天所有成交记录
    trades = get_trades()
    for _trade in trades.values():
        log.info('成交记录：'+str(_trade))
    log.info('一天结束')
    log.info('##############################################################')

```

# 策略12

```python
# 导入函数库
from jqdata import *

# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    # log.set_level('order', 'error')
    
    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')
    
    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') 
      # 开盘时运行
    run_daily(market_open, time='open', reference_security='000300.XSHG')
      # 收盘后运行
    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')
    
## 开盘前运行函数     
def before_market_open(context):
    # 输出运行时间
    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))

    # 给微信发送消息（添加模拟交易，并绑定微信生效）
    send_message('美好的一天~')

    # 要操作的股票：平安银行（g.为全局变量）
    g.security = '000001.XSHE'
    
## 开盘时运行函数
def market_open(context):
    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))
    security = g.security
    # 获取股票的收盘价
    close_data = attribute_history(security, 5, '1d', ['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.available_cash

    # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    if current_price > 1.01*MA5:
        # 记录这次买入
        log.info("价格高于均价 1%%, 买入 %s" % (security))
        # 用所有 cash 买入股票
        order_value(security, cash)
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 记录这次卖出
        log.info("价格低于均价, 卖出 %s" % (security))
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)
 
## 收盘后运行函数  
def after_market_close(context):
    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))
    #得到当天所有成交记录
    trades = get_trades()
    for _trade in trades.values():
        log.info('成交记录：'+str(_trade))
    log.info('一天结束')
    log.info('##############################################################')

```

# Talib-ATR-Close

```python
# 克隆自聚宽文章：https://www.joinquant.com/post/134
# 标题：量化投资学习【TA-LIB】之ATR
# 作者：冰柠檬

#此例子采用Talib提供的平均真实波幅ATR指标作为买入/卖出信号。
#如果当前价格比之前的价格高一个ATR的涨幅，买入股票
#如果之前的价格比当前价格高一个ATR的涨幅，卖出股票
import talib
#import numpy as np
#import pandas as pd

def initialize(context):
    # 定义一个全局变量, 保存要操作的证券
    context.stocks = ['601328.XSHG','600036.XSHG','600196.XSHG','600010.XSHG']
    # 设置我们要操作的股票池
    set_universe(context.stocks)
# 初始化此策略
def handle_data(context, data):
    # 取得当前的现金
    cash = context.portfolio.cash
    # 循环股票列表
    for stock in context.stocks:
        # 获取股票的数据
        h = attribute_history(stock, 30, '1d', ('high','low','close'))
        # 创建ATR买卖信号，包括最高价，最低价，收盘价和参数timeperiod
        # 注意：ATR函数使用的price必须是narray
        atr = talib.ATR(h['high'].values,h['low'].values,h['close'].values, timeperiod=14)[-1]
        # 获取当前股票的数据
        current_position = context.portfolio.positions[stock].amount
        # 获取当前股票价格
        current_price = data[stock].price
        #获取四天前的收盘价
        prev_close = h['close'].values[-5]
        #如果当前价格比之前的价格高一个ATR的涨幅，买入股票
        upside_signal = current_price - (prev_close + atr)
        #如果之前的价格比当前价格高一个ATR的涨幅，卖出股票
        downside_signal = prev_close - (current_price + atr)
        # 当downside_signal大于0，且拥有的股票数量大于0时，卖出所有股票
        if downside_signal > 0 and current_position > 0:
            order_target(stock, 0)
        # 当upside_signal大于0, 且拥有的股票数量为0时，则全仓买入
        elif upside_signal > 0 and current_position == 0:
            number_of_shares = int(cash/current_price)
            # 购买量大于0时，下单
            if number_of_shares > 0:
                # 买入股票
                order(stock, +number_of_shares)
                # 记录这次买入
                log.info("Buying %s" % (stock))
    #record(upside_signal=upside_signal,downside_signal=downside_signal,ATR=atr)

```

# 海龟交易法则观看

```python
# 克隆自聚宽文章：https://www.joinquant.com/post/49
# 标题：量化投资学习【常见策略】6-海龟交易系统
# 作者：Kris

import numpy as np      
import pandas as pd
from pandas import Series,DataFrame
import random
import math
# 定义一个全局变量, 保存要操作的证券
security='600196.XSHG'
# 设置我们要操作的股票池, 这里我们只操作一支股票
set_universe([security])
set_benchmark('600196.XSHG')
#设置回测条件
set_commission(PerTrade(buy_cost=0.0008, sell_cost=0.0015, min_cost=5))
set_slippage(FixedSlippage(0))
#调整资金规模时的临界损失比例
loss=0.1
#调整资金规模时调整后的资金占当前资金的比例
adjust=0.8
#计算第一个N时取得股票数据的天数
days=20
#系统一入市时股票价格需要高于short_in天内的最高价
short_in=20
#系统二入市时股票价格需要高于long_in天内的最高价
long_in=55
#系统一离市时股票价格需要低于short_out天内的最低价
short_out=10
#系统二离市时股票价格需要低于long_out天内的最低价
long_out=20
#系统一和系统二的资金分配比例，系统一得到ratio*总资金，系统二得到（1-ratio）*总资金
ratio=0.7
#单一市场中的头寸规模限制
limit=4
#记录策略运行了多少天
pdn=0
#记录N值
N=[]
#记录系统一中股票的单位数
sys1=0 
#记录系统二中股票的单位数
sys2=0
#判断操作是对系统一还是系统二，值为‘True’是对系统一，‘False’是对系统二
short='False'
#用unit来保存一单位表示多少股票，默认值为1000
unit=1000
#记录系统一形成突破时的股票价格
break_price1=0 
#记录系统二形成突破时的股票价格
break_price2=0
#记录分钟
minutes=0

#计算股票的N值 
def Calcu_N(context,paused):
    #在策略运行了days-1天时，计算前days-1天的平均实际范围
    if pdn==days-1:
        #取出day-1天来得最高价，最低价，前一天的收盘价
        price=attribute_history(security,days-1,'1d', ('high','low','pre_close'),skip_paused=True)
        #如果不是所有的这day-1天都没有数据，算出这些天的实际范围的平均值
        TR=[]
        for i in range(0,days-1):
            h_l=price['high'][i]-price['low'][i]
            h_pdc=price['high'][i]-price['pre_close'][i]
            pdc_l=price['pre_close'][i]-price['low'][i]
            temp=max(h_l,h_pdc,pdc_l)
            TR.append(temp)
        ATR=np.mean(np.array(TR))
        N.append(ATR)
        
    #如果策略运行天数已经达到了days天
    else:
        #如果股票停牌，则将运行天数减1
        if paused==True:
            global pdn
            pdn=pdn-1
        #如果未停牌，则利用迭代，计算N值，并保存在列表N中
        else:
            price=attribute_history(security,1,'1d', ('high','low','pre_close'),skip_paused=True)
            h_l=price['high'][0]-price['low'][0]
            h_pdc=price['high'][0]-price['pre_close'][0]
            pdc_l=price['pre_close'][0]-price['low'][0]
            temp=max(h_l,h_pdc,pdc_l)
            TR.append(temp)
            ATR=np.mean(np.array(TR))
            N.append(ATR)
            
#止损
def Stop_Loss(current_price):
    #如果对系统一操作，则将突破价设置为系统一的突破价，如果是对系统二，则设置为系统二的
    if short=='True':
        break_price=break_price1
    else:
        break_price=break_price2
    #如果当前价格比上次的突破价低2N，则清空头寸
    #并相应的更改相应系统中的股票单位数
    if current_price<break_price-2*N[-1]:
        if short=='True':
            order(security,-sys1)
            global sys1
            sys1=0  
        else:
            order(security,-sys2)
            global sys2 
            sys2=0
            
#入市
def Sys_In(highest,day_in,context, current_price,cash):
    #取出day_in天以来的最高价
    price=attribute_history(security,day_in,'1d',('high','open'))
    #如果当前价格高于day_in天的最高价，则形成突破
    if current_price>max(price['high']) and current_price>=highest:
        #计算可以买的股票数量
        num_of_shares=cash/current_price
        #如果可以买的数量不小于一单位，且目前持有的股票数量未达到限制的数量，则买入
        if num_of_shares>=unit:
            if short=='True':
                if sys1<int(limit*unit):
                    order(security,+int(unit))
                    #买入后，相应的更新持有的股票数及突破价格
                    global sys1
                    sys1=sys1+int(unit)
                    global break_price1
                    break_price1=current_price
            else:
                if sys2<int(limit*unit):
                    order(security,+int(unit))
                    global sys2
                    sys2=sys2+int(unit)
                    global break_price2
                    break_price2=current_price
    
#增加单位    
def Sys_Add(day_in,context,current_price,cash):
    #根据short的值判断是对哪个系统操作，以对突破价格赋值
    if short=='True':
        break_price=break_price1
    else:
        break_price=break_price2
    #如果当前价格比上次的突破价格高0.5*N，则增加一单位
    if current_price>=break_price+0.5*N[-1]: 
        num_of_shares=cash/current_price
        if num_of_shares>=unit: 
            if short=='True':
                if sys1<int(limit*unit):
                    order(security,+int(unit))
                    global sys1
                    sys1=sys1+int(unit)
                    global break_price1
                    break_price1=current_price
            else:
                if sys2<int(limit*unit):
                    order(security,+int(unit))
                    global sys2
                    sys2=sys2+int(unit)
                    global break_price2
                    break_price2=current_price
    
# 离市
def Sys_Out(day_out,current_price,context):
    #取出day_out天以来的最低价
    price=attribute_history(security,day_out,'1d',('high','low'),skip_paused=True)
    #如果股票当前价格比day_out天的最低价低，则清空系统内的头寸
    #并将相应系统的头寸数量置为0
    if current_price<min(price['low']):
        if short=='True':
            if sys1>0:
                order(security,-sys1)
                global sys1
                sys1=0
        else:
            if sys2>0:
                order(security,-sys2)
                global sys2
                sys2=0

#每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次
def handle_data(context, data):
    global minutes
    minutes=minutes+1
    price=attribute_history(security,minutes,'1m',('high','price','open'),skip_paused=True)
    #取得从今天开盘为止的最高价
    highest=max(price['open'])
    #用paused保存股票是否停牌
    paused=data[security].paused
    #用dt保存当前时间
    dt=context.current_dt
    #保存当前股票价格
    current_price=data[security].price
    #保存资产组合的总值
    value=context.portfolio.portfolio_value
    #在每天开市时将策略运行时间加1
    if dt.hour==9 and dt.minute==30:
        global minutes
        minutes=0
        global pdn 
        pdn=pdn+1
        #在运行时间达到days-1天时计算头寸单位
        if pdn==days-1:
            Calcu_N(context,paused)
    #运行时间达到days天时开始执行各种买卖操作
    if pdn>=days:
        if pdn==days:
            global break_price1
            break_price1=current_price*5+1
        #如果股票不停牌
        if paused==False:
            #取得当前现金
            cash=context.portfolio.cash
            #如果空仓了
            if sys1==0 and sys2==0:
                #调整资金规模
                if context.portfolio.portfolio_value<(1-loss)*context.portfolio.starting_cash:
                    cash=adjust*cash
                    value=adjust*value
            #每点价值量（yuan per point）
            ypp=1.0
            #价值量波动性 value volatility
            vv=ypp*N[-1]
            #计算一单位的数量
            global unit
            unit=value*0.01/vv
            #将short置为‘True’，对系统一进行操作
            global short
            short='True'
            #如果系统一没有头寸，并且当前价格比上次的突破价低，入市
            if sys1==0:
                #入市
                Sys_In(highest,short_in,context,current_price,ratio*cash)
            #如果已经有了头寸，则进行止损或者增加单位
            else:
                #止损
                Stop_Loss(current_price)
                #增加单位
                Sys_Add(short_in,context,current_price,ratio*cash)    
            #离市
            Sys_Out(short_out,current_price,context)
            #将short置为‘False’，对系统二进行操作
            global short
            short='False'
            if sys2==0:
                #入市
                Sys_In(highest,long_in,context,current_price,(1-ratio)*cash)
            else:
                Stop_Loss(current_price)
                Sys_Add(long_in,context,current_price,(1-ratio)*cash)
            #离市
            Sys_Out(long_out,current_price,context)   
```

# 手写海龟交易法则

```python
'''

def initialize(context):
    run_daily(period, time="every_bar")
    g.security1="000007.XSHE"
    g.security2="000005.XSHE"

def period(context):
    order(g.security1,100)
    order(g.security2,100)
    '''
'''    
def initialize(context):
    run_daily(period, time="every_bar")
    g.security=["000007.XSHE","000005.XSHE"]
    

def period(context):
    for i in g.security:
        order(i,100)#每只股票买100股
'''
'''
lis1=[]
for i in range(1,101):
    lis1.append(i**2)
    print(lis1)
    '''
'''   
a = [4,2,1,9,6,5,3,8,7]
for i in range(len(a)):
  for j in range(i+1,len(a)):
      if a[j] <= a[i]:
          t=a[j]
          a[j] = a[i]
          a[i]=t
print(a)
'''
'''
t=get_index_stocks("000016.XSHG", "2018-03-01")
print(t[0])
print(t)
'''
'''
w=history(count=4, unit='5d', field="money", security_list=["000007.XSHE","000016.XSHE"])
print(w)
'''

'''
w=attribute_history(security="000001.XSHE", count=4, unit="6d", fields=["money","high","open"])

print(w)
print(w.index)#这个功能是将最后的输出格式进行转化和调整。
print(w.loc[:,["open","high"]])#选取几个作为输出
print(w.loc[["2016-05-05","2016-05-13"]])#特定日期的列表
print(w.T)#行和列互换


'''
'''
#query(表.字段).filter(筛选条件).order_by(排序方法).limit(数量上限)
#比较长的话可以分行写
q=query(valuation.code,balance.retained_profit).filter(valuation.market_cap<=100,valuation.pe_ratio>=10).order_by(valuation.market_cap.desc()).limit(10)
w=get_fundamentals(q)
print(w)
'''

'''
#获取任一股票最近5个交易日最高价的平均价,fq默认是前复权的意思，df默认为ture列表的意思。
w=history(count=5, unit="1d", field="high", security_list=["000001.XSHE"] )
avg1=sum(w.values)/5
print(avg1)
'''

'''
#生成一个list，list中为上证指数成分股中流通市值最大5个股票的代码。
t=get_index_stocks("000001.XSHG","2018-06-06")
q=query(valuation.code,valuation.circulating_market_cap).filter(valuation.code.in_(t)).order_by(valuation.circulating_market_cap.desc()).limit(5)
w=get_fundamentals(q)
print(w.code)
'''

'''
#  设定好要交易的股票数量stocksnum 
  每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
  若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
  买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。
'''
'''
def initialize(context):
    run_daily(period,time="every_bar")
    g.stocksnum=10
    #设定要交易代码的数量
    
    
def period(context):
    #每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
    security1=get_index_stocks("000001.XSHG")
    security2=get_index_stocks("399106.XSHE")
    security0=security1+security2
    q=query(valuation.code,valuation.market_cap).filter(valuation.code.in_(security0)).order_by(valuation.market_cap.asc()).limit(g.stocksnum)
    df=get_fundamentals(q)
    chilist=list(df['code'])
    #print(xiaoyu7)
    print(chilist)
    #若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
    for i in context.portfolio.positions:#股票i在持仓里面
        if i not in chilist:#如果i不在选出的池子里面，则卖出
            order_target(i,0)
    
    #买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。 
    bili=context.portfolio.available_cash/g.stocksnum
    for i in chilist:
        order_value(i,bili)
    
   ''' 
'''   
 #调整与改进
 #每period(可用设置不同的周期)，控制周期进行买票
 
def initialize(context):
    run_daily(period,time="every_bar")
    g.stocksnum=7
    g.period=6
    g.days=0
    #设定要交易代码的数量
    
    
def period(context):
    if g.days%g.period==0:#这个说明每六天余数为0时，这个程序就会执行一次
        #每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
        security1=get_index_stocks("000001.XSHG")
        security2=get_index_stocks("399106.XSHE")
        security0=security1+security2
        q=query(valuation.code,valuation.market_cap).filter(valuation.code.in_(security0)).order_by(valuation.market_cap.asc()).limit(g.stocksnum)
        df=get_fundamentals(q)
        chilist=list(df['code'])
    #print(xiaoyu7)
        print(chilist)
    #若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
        for i in context.portfolio.positions:#股票i在持仓里面
            if i not in chilist:#如果i不在选出的池子里面，则卖出
                order_target(i,0)
    
    #买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。 
        bili=context.portfolio.available_cash/g.stocksnum
        for i in chilist:
            order_value(i,bili)  

    g.days=g.days+1
   
'''  

#系统1，20日单位突破法则



#买入价格为当前资金总额的10%除以绝对波动幅度，绝对波动幅度为N乘以每变动一点后的人民币。
#头寸设有上限，单只股票不能超过20%，
#只有前次交易为亏损型的时候才为有效突破，才可以买入，
#亏损型为在10日突破法则之前，出现2N的不利波动
#止损，最新入市价格的2N处。
#推出为所有价格的10日最低点。
#后期对同行业也进行股票的仓位限制


import jqdata#导入聚宽数据库
x=[]

def initialize(context): #初始化函数
    run_daily(period, time="every_bar")#每天或每分钟执行
    set_option("use_real_price",True)#开启动态复权价格
    g.stocknum=10#股票数量设置为10只

def period(context):
    sec1=get_index_stocks("000001.XSHG")
    sec2=get_index_stocks("399005.XSHE")
    sec3=get_index_stocks("399006.XSHE")
    secall=sec1+sec2+sec3#全A股市场股票

    #挑选20只股票流通市值大于51亿的,市盈率大于1的,按照流通市值从小到大排序，前20的入选股票池
    up=query(valuation.code,valuation.circulating_market_cap).filter(valuation.code.in_(secall),valuation.circulating_market_cap>=51,valuation.pe_ratio>=1).order_by(valuation.circulating_market_cap.asc()).limit(g.stocknum)
    
    
    sp=get_fundamentals(up)
    sp0=list(sp["code"])
    #stockpool=sp0为真正的股票池
    for per_security in sp0:
        h1=attribute_history(per_security,20,"1d",("high","close"),skip_paused=True,df=False)#3、股票的20日的最高价格，形成列表
        h2=h1["high"]#4、取出每日收盘的最高价
        h3=max(h2)#5、选出前20日的最高价格
        h4=h1["close"][-1] #6、获得前一分钟切片价格
        if h4>h3:
            order(per_security,100)
        
        
   
    #买入标准为突破过去20日最高点的交易价格，如果价格上升到1/2N时买入。

    #print(h1["high"])
    #print(A1)
    #超过20日最高点价格则买入

```

# 多股票策略

```python
'''

def initialize(context):
    run_daily(period, time="every_bar")
    g.security1="000007.XSHE"
    g.security2="000005.XSHE"

def period(context):
    order(g.security1,100)
    order(g.security2,100)
    '''
'''    
def initialize(context):
    run_daily(period, time="every_bar")
    g.security=["000007.XSHE","000005.XSHE"]
    

def period(context):
    for i in g.security:
        order(i,100)#每只股票买100股
'''
'''
lis1=[]
for i in range(1,101):
    lis1.append(i**2)
    print(lis1)
    '''
'''   
a = [4,2,1,9,6,5,3,8,7]
for i in range(len(a)):
  for j in range(i+1,len(a)):
      if a[j] <= a[i]:
          t=a[j]
          a[j] = a[i]
          a[i]=t
print(a)
'''
'''
t=get_index_stocks("000016.XSHG", "2018-03-01")
print(t[0])
print(t)
'''
'''
w=history(count=4, unit='5d', field="money", security_list=["000007.XSHE","000016.XSHE"])
print(w)
'''

'''
w=attribute_history(security="000001.XSHE", count=4, unit="6d", fields=["money","high","open"])

print(w)
print(w.index)#这个功能是将最后的输出格式进行转化和调整。
print(w.loc[:,["open","high"]])#选取几个作为输出
print(w.loc[["2016-05-05","2016-05-13"]])#特定日期的列表
print(w.T)#行和列互换


'''
'''
#query(表.字段).filter(筛选条件).order_by(排序方法).limit(数量上限)
#比较长的话可以分行写
q=query(valuation.code,balance.retained_profit).filter(valuation.market_cap<=100,valuation.pe_ratio>=10).order_by(valuation.market_cap.desc()).limit(10)
w=get_fundamentals(q)
print(w)
'''

'''
#获取任一股票最近5个交易日最高价的平均价,fq默认是前复权的意思，df默认为ture列表的意思。
w=history(count=5, unit="1d", field="high", security_list=["000001.XSHE"] )
avg1=sum(w.values)/5
print(avg1)
'''

'''
#生成一个list，list中为上证指数成分股中流通市值最大5个股票的代码。
t=get_index_stocks("000001.XSHG","2018-06-06")
q=query(valuation.code,valuation.circulating_market_cap).filter(valuation.code.in_(t)).order_by(valuation.circulating_market_cap.desc()).limit(5)
w=get_fundamentals(q)
print(w.code)
'''

'''
#  设定好要交易的股票数量stocksnum 
  每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
  若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
  买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。
'''
'''
def initialize(context):
    run_daily(period,time="every_bar")
    g.stocksnum=10
    #设定要交易代码的数量
    
    
def period(context):
    #每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
    security1=get_index_stocks("000001.XSHG")
    security2=get_index_stocks("399106.XSHE")
    security0=security1+security2
    q=query(valuation.code,valuation.market_cap).filter(valuation.code.in_(security0)).order_by(valuation.market_cap.asc()).limit(g.stocksnum)
    df=get_fundamentals(q)
    chilist=list(df['code'])
    #print(xiaoyu7)
    print(chilist)
    #若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
    for i in context.portfolio.positions:#股票i在持仓里面
        if i not in chilist:#如果i不在选出的池子里面，则卖出
            order_target(i,0)
    
    #买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。 
    bili=context.portfolio.available_cash/g.stocksnum
    for i in chilist:
        order_value(i,bili)
    
   ''' 
  ''' 
 #调整与改进
 #每period(可用设置不同的周期)，控制周期进行买票
 
def initialize(context):
    run_daily(period,time="every_bar")
    g.stocksnum=7
    g.period=6
    g.days=0
    #设定要交易代码的数量
    
    
def period(context):
    if g.days%g.period==0:#这个说明每六天余数为0时，这个程序就会执行一次
        #每天找出市值排名最小的前stocksnum只股票作为要买入的股票。
        security1=get_index_stocks("000001.XSHG")
        security2=get_index_stocks("399106.XSHE")
        security0=security1+security2
        q=query(valuation.code,valuation.market_cap).filter(valuation.code.in_(security0)).order_by(valuation.market_cap.asc()).limit(g.stocksnum)
        df=get_fundamentals(q)
        chilist=list(df['code'])
    #print(xiaoyu7)
        print(chilist)
    #若已持有的股票的市值已经不够小而不在要买入的股票中，则卖出这些股票。
        for i in context.portfolio.positions:#股票i在持仓里面
            if i not in chilist:#如果i不在选出的池子里面，则卖出
                order_target(i,0)
    
    #买入要买入的股票，买入金额为当前可用资金的stocksnum分之一。 
        bili=context.portfolio.available_cash/g.stocksnum
        for i in chilist:
            order_value(i,bili)  

    g.days=g.days+1
   
  '''
  
import talib  
  # 定义股票池列表
security_list1 = ['000001.XSHE']
security_list2 = ['000001.XSHE','000002.XSHE','601211.XSHG','603177.XSHG']
# 计算并输出 security_list1 的 ATR 值
MTR1,ATR1 = ATR(security_list1, check_date='2017-01-04', timeperiod=14)
    print MTR1[security_list1]
    print ATR1[security_list1]

# 输出 security_list2 的 ATR 值
MTR2,ATR2 = ATR(security_list2, check_date='2017-01-04', timeperiod=14)
    for stock in security_list2:
        print MTR2[stock]
        print ATR2[stock]

```

# 关于context几个代码的测试

```python
#测试1：提取context中的各种数据
'''测试可行
def initialize(context):
    run_daily(period, time="every_bar")
    g.security="000001.XSHE"

def period(context):
    order(g.security,100)#以下都根据聚宽内置context数据库写的
    print(context.portfolio.positions.keys())#打印标的代码
    print(context.portfolio.positions.values())#打印标的对应的价值
    print(context.portfolio.positions[g.security].avg_cost)#打印标的开仓均价
    代码结束了
'''
    
#学习if语句，判断a的大小
'''a=int(input("输入一个数："))
if a>0:
    if a<1:
        print("a大于0且小于1")
    else:
        print("a大于等于1")
else:
    print("a小于等于0")
'''
'''测试可以用
'''
    
'''以下是止损的写法
'''
    
'''    
def initialize(context):
    run_daily(period, time="every_bar")
    g.security="000001.XSHE"
    
def period(context):
    order(g.security,100)#每天买入100股
    cost=context.portfolio.positions["000001.XSHE"].avg_cost#以cost对象命名的一个参数，获得股票的持仓成本
    price=context.portfolio.positions["000001.XSHE"].price#以price命名的一个获得当前的价格
    ret=price/cost-1#计算收益率
    #下面打印日志
    print('成本价：%s'% cost)#显示成本价
    print('现价：%s'% Price)#显示现价
    print('收益率：%s'% ret)#显示收益率
    #亏损达到1%则卖出股票，仓位减为0
    if ret<-0.01:
        order_target('000001.XSHE',0)
        print("触发止损")
'''        
        
        
#写一个策略，内容为在20180301买入一个股票，在20180321卖出一个股票。

'''
date1=context.current_dt.strftime("%Y-%m-%d")

def initialize(context):
   run_daily(period, time="every_bar")
   g.security="000006.XSHE"
   
def period(context):
    if date1=="2018-3-1":
        order("000006.XSHE",100)
        cost=context.portfolio.positions["000006.XSHE"].avgcost
    elif data1=="2018-3-21"
        order_target('000006.XSHE',0)
        price=context.portfolio.positions["000006.XSHE"].price
        ret=100*(price-cost)
        print(ret)
'''
'''
#设置一个止盈的例子
def initialize(context):
    run_daily(period, time="every_bar")
    g.security="000001.XSHE"
    
def period(context):
    order(g.security,100)
    cost=context.portfolio.positions["000001.XSHE"].avg_cost
    price=context.portfolio.positions["000001.XSHE"].price
    ret=price/cost-1
    print("成本价：%s"% cost)
    print("现价：%s"% price)
    print("成本价：%s"% ret)
    if ret>=0.1:
        order_target(g.security,0)    
        print("触发止盈")
        
'''
'''这个策略成功执行了'''

'''练习找出闰年'''
'''
dates=[]
for i in range(1970,2071):
    if i%4==0 and i%100!=0 or i%400==0:
        dates.append(i)
        print(dates)
'''

```

# 聚宽模块context的一些数据提取和运用

```python
def initialize(context):
      run_daily(period,time='every_bar')
      g.security = '000001.XSHE'
def period(context):
      order(g.security, 100)
      print(context.portfolio.available_cash)
      print(context.run_params.frequency)
      print(context.current_dt)
```

# 使用聚宽的四个order函数练习

```python
'''
出的题目如下
1、order函数写平安银行股票每周买入100股
2、用order_target函数写调仓，比如000002万科股票调整在1000股不动
3、用order_value(security, value, style, side, pindex)函数写，比如000006深振业A买入价值100元股票
4、用order_target_value(security, value, style, side, pindex)写，比如600002齐鲁石化仓位调整至10000元
'''

def initialize(context):#初始化账户信息
    run_daily(period, time="every_bar")
def period(context):
    order("000001.XSHE",100)#固定买入100股每天
    order_value("000006.XSHE",700)#固定买深振业700元价值股票不变每天
    order_target("000002.XSHE", 1000)#调整仓位1000股万科股票不变每天
    order_target_value("600002.XSHG",5000)#将齐鲁石化仓位在价值5000元不变动
```

# 我的第一段代码

```python
'''def initialize(context):#本人理解为数据提供一个传入接口
    run_daily(period,time="every_bar")#定义的函数里面，参数应该是与股票数据对应
    g.security="600462.XSHG"#每天买九有股份的票，security是有家证券的意思，g是全局变量附加，意思是对全部代码有效
    
def period(context):#定义一个时间函数
     order(g.security,100)
     
     

```

# 海归策略-clone

```python
# 克隆自聚宽文章：https://www.joinquant.com/post/1401
# 标题：【量化课堂】海龟策略
# 作者：JoinQuant量化课堂

#海归策略
# 2012-01-01 到 2016-03-10, ￥1000000, 分钟
'''
================================================================================
总体回测前
================================================================================
'''
#总体回测前要做的事情
def initialize(context):
    set_params()        #1设置策参数
    set_variables()     #2设置中间变量
    set_backtest()      #3设置回测条件
    
#1
#设置策略参数
def set_params():
    g.security = '000063.XSHE'
    # 系统1入市的trailing date
    g.short_in_date = 20
    # 系统2入市的trailing date
    g.long_in_date = 55
    # 系统1 exiting market trailing date
    g.short_out_date = 10
    # 系统2 exiting market trailing date
    g.long_out_date = 20
    # g.dollars_per_share是标的股票每波动一个最小单位，1手股票的总价格变化量。
    # 在国内最小变化量是0.01元，所以就是0.01×100=1
    g.dollars_per_share = 1
    # 可承受的最大损失率
    g.loss = 0.1
    # 若超过最大损失率，则调整率为：
    g.adjust = 0.8
    # 计算N值的天数
    g.number_days = 20
    # 最大允许单元
    g.unit_limit = 4
    # 系统1所配金额占总金额比例
    g.ratio = 0.8
    
#2
#设置中间变量
def set_variables():
    # 初始单元
    g.unit = 1000
    # A list storing info of N
    g.N = []
    # Record the number of days for this trading system
    g.days = 0
    # 系统1的突破价格
    g.break_price1 = 0
    # 系统2的突破价格
    g.break_price2 = 0
    # 系统1建的仓数
    g.sys1 = 0
    # 系统2建的仓数
    g.sys2 = 0
    # 系统1执行且系统2不执行
    g.system1 = True

#3
#设置回测条件
def set_backtest():
    # 作为判断策略好坏和一系列风险值计算的基准
    set_benchmark(g.security)
    set_option('use_real_price',True) #用真实价格交易
    log.set_level('order','error') # 设置报错等级




'''
================================================================================
每天开盘前
================================================================================
'''
#每天开盘前要做的事情
def before_trading_start(context):
    set_slip_fee(context) 


#4 根据不同的时间段设置滑点与手续费
def set_slip_fee(context):
    # 将滑点设置为0
    set_slippage(FixedSlippage(0)) 
    # 根据不同的时间段设置手续费
    dt=context.current_dt
    
    if dt>datetime.datetime(2013,1, 1):
        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5)) 
        
    elif dt>datetime.datetime(2011,1, 1):
        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))
            
    elif dt>datetime.datetime(2009,1, 1):
        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))
                
    else:
        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))




'''
================================================================================
每天交易时
================================================================================
'''
# 按分钟回测
def handle_data(context, data):
    dt = context.current_dt # 当前日期
    current_price = data[g.security].price # 当前价格N
    if dt.hour==9 and dt.minute==30:
        g.days += 1
        calculate_N() #计算N的值
    if g.days > g.number_days:
        # 当前持有的股票和现金的总价值
        value = context.portfolio.portfolio_value
        # 可花费的现金
        cash = context.portfolio.cash 
        if g.sys1 == 0 and g.sys2 == 0:
            # 若损失率大于g.loss，则调整（减小）可持有现金和总价值
            if value < (1-g.loss)*context.portfolio.starting_cash:
                cash *= g.adjust
                value *= g.adjust
                
        # 计算美元波动的价格
        dollar_volatility = g.dollars_per_share*(g.N)[-1]
        # 依本策略，计算买卖的单位
        g.unit = value*0.01/dollar_volatility

        # 系统1的操作
        g.system1 = True
        if g.sys1 == 0:
            market_in(current_price, g.ratio*cash, g.short_in_date)
        else:
            stop_loss(current_price)
            market_add(current_price, g.ratio*cash, g.short_in_date)    
            market_out(current_price, g.short_out_date)

        # 系统2的操作
        g.system1 == False
        if g.sys2==0:
            market_in(current_price, (1-g.ratio)*cash, g.long_in_date)
        else:
            stop_loss(current_price)
            market_add(current_price, (1-g.ratio)*cash, g.long_in_date)
            market_out(current_price, g.long_out_date)   
  

#5
# 计算当前N的值
# 输入：none
# 输出：N的值的更新列表-list类型
def calculate_N():
    # 如果交易天数小于等于20天
    if g.days <= g.number_days:
        price = attribute_history(g.security, g.days, '1d',('high','low','close'))
        lst = []
        for i in range(0, g.days):
            h_l = price['high'][i]-price['low'][i]
            h_c = price['high'][i]-price['close'][i]
            c_l = price['close'][i]-price['low'][i]
            # 计算 True Range
            True_Range = max(h_l, h_c, c_l)
            lst.append(True_Range)
        # 计算前g.days（小于等于20）天的True_Range平均值，即当前N的值：
        current_N = np.mean(np.array(lst))
        (g.N).append(current_N)
        
    # 如果交易天数超过20天
    else:
        price = attribute_history(g.security, 1, '1d',('high','low','close'))
        h_l = price['high'][0]-price['low'][0]
        h_c = price['high'][0]-price['close'][0]
        c_l = price['close'][0]-price['low'][0]
        # Calculate the True Range
        True_Range = max(h_l, h_c, c_l)
        # 计算前g.number_days（大于20）天的True_Range平均值，即当前N的值：
        current_N = (True_Range + (g.number_days-1)*(g.N)[-1])/g.number_days
        (g.N).append(current_N)


#6
# 入市：决定系统1、系统2是否应该入市，更新系统1和系统2的突破价格
# 海龟将所有资金分为2部分：一部分资金按系统1执行，一部分资金按系统2执行
# 输入：当前价格-float, 现金-float, 天数-int
# 输出：none
def market_in(current_price, cash, in_date):
    # Get the price for the past "in_date" days
    price = attribute_history(g.security, in_date, '1d', ('close'))
    # Build position if current price is higher than highest in past
    if current_price > max(price['close']):
        # 计算可以买该股票的股数
        num_of_shares = cash/current_price
        if num_of_shares >= g.unit:
            print "买入"
            print current_price
            print max(price['close'])
            if g.system1 == True:
                if g.sys1 < int(g.unit_limit*g.unit):
                    order(g.security, int(g.unit))
                    g.sys1 += int(g.unit)
                    g.break_price1 = current_price
            else:
                if g.sys2 < int(g.unit_limit*g.unit):
                    order(g.security, int(g.unit))
                    g.sys2 += int(g.unit)
                    g.break_price2 = current_price


#7
# 加仓函数
# 输入：当前价格-float, 现金-float, 天数-int
# 输出：none
def market_add(current_price, cash, in_date):
    if g.system1 == True:
        break_price=g.break_price1
    else:
        break_price=g.break_price2
    # 每上涨0.5N，加仓一个单元
    if current_price >= break_price + 0.5*(g.N)[-1]: 
        num_of_shares = cash/current_price
        # 加仓
        if num_of_shares >= g.unit: 
            print "加仓"
            print g.sys1
            print g.sys2
            print current_price
            print break_price + 0.5*(g.N)[-1]
       
            if g.system1 == True:
                if g.sys1 < int(g.unit_limit*g.unit):
                    order(g.security, int(g.unit))
                    g.sys1 += int(g.unit)
                    g.break_price1 = current_price
            else:
                if g.sys2 < int(g.unit_limit*g.unit):
                    order(g.security, int(g.unit))
                    g.sys2 += int(g.unit)
                    g.break_price2 = current_price


#8
# 离场函数
# 输入：当前价格-float, 天数-int
# 输出：none
def market_out(current_price, out_date):
    # Function for leaving the market
    price = attribute_history(g.security, out_date, '1d', ('close'))
    # 若当前价格低于前out_date天的收盘价的最小值, 则卖掉所有持仓
    if current_price < min(price['close']):
        print "离场"
        print current_price
        print min(price['close'])
        if g.system1 == True:
            if g.sys1>0:
                order(g.security, -g.sys1)
                g.sys1 = 0
        else:
            if g.sys2>0:
                order(g.security, -g.sys2)
                g.sys2 = 0

#9
# 止损函数
# 输入：当前价格-float
# 输出：none
def stop_loss(current_price):
    # 损失大于2N，卖出股票
    if g.system1 == True:
        break_price = g.break_price1
    else:
        break_price = g.break_price2
    # If the price has decreased by 2N, then clear all position
    if current_price < (break_price - 2*(g.N)[-1]):
        print "止损"
        print current_price
        print break_price - 2*(g.N)[-1]
        if g.system1 == True:
            order(g.security, -g.sys1)
            g.sys1 = 0  
        else:
            order(g.security, -g.sys2)
            g.sys2 = 0

'''
================================================================================
每天收盘后
================================================================================
'''
# 每日收盘后要做的事情（本策略中不需要）
def after_trading_end(context):
    return
################################################################################
```

# 小市值策略

```python
'''
筛选出市值介于20-30亿的股票，选取其中市值最小的三只股票，
每天开盘买入，持有五个交易日，然后调仓。
'''

## 初始化函数，设定要操作的股票、基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # True为开启动态复权模式，使用真实价格交易
    set_option('use_real_price', True) 
    # 设定成交量比例
    set_option('order_volume_ratio', 1)
    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, \
                             open_commission=0.0003, close_commission=0.0003,\
                             close_today_commission=0, min_commission=5), type='stock')
    # 持仓数量
    g.stocknum = 3 
    # 交易日计时器
    g.days = 0 
    # 调仓频率
    g.refresh_rate = 5
    # 运行函数
    run_daily(trade, 'every_bar')

## 选出小市值股票
def check_stocks(context):
    # 设定查询条件
    q = query(
            valuation.code,
            valuation.market_cap
        ).filter(
            valuation.market_cap.between(20,30)
        ).order_by(
            valuation.market_cap.asc()
        )

    # 选出低市值的股票，构成buylist
    df = get_fundamentals(q)
    buylist =list(df['code'])

    # 过滤停牌股票
    buylist = filter_paused_stock(buylist)

    return buylist[:g.stocknum]
  
## 交易函数
def trade(context):
    if g.days%g.refresh_rate == 0:

        ## 获取持仓列表
        sell_list = list(context.portfolio.positions.keys())
        # 如果有持仓，则卖出
        if len(sell_list) > 0 :
            for stock in sell_list:
                order_target_value(stock, 0)

        ## 分配资金
        if len(context.portfolio.positions) < g.stocknum :
            Num = g.stocknum - len(context.portfolio.positions)
            Cash = context.portfolio.cash/Num
        else: 
            Cash = 0

        ## 选股
        stock_list = check_stocks(context)

        ## 买入股票
        for stock in stock_list:
            if len(context.portfolio.positions.keys()) < g.stocknum:
                order_value(stock, Cash)

        # 天计数加一
        g.days = 1
    else:
        g.days += 1

# 过滤停牌股票
def filter_paused_stock(stock_list):
    current_data = get_current_data()
    return [stock for stock in stock_list if not current_data[stock].paused]

```

# 双均线策略

```python
'''
双均线策略，当五日均线位于十日均线上方则买入，反之卖出。
'''

## 初始化函数，设定要操作的股票、基准等等
def initialize(context):
    # 定义一个全局变量, 保存要操作的股票
    # 000002(股票:万科A)
    g.security = '000002.XSHE'
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # True为开启动态复权模式，使用真实价格交易
    set_option('use_real_price', True) 
    # 设定成交量比例
    set_option('order_volume_ratio', 1)
    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, \
                             open_commission=0.0003, close_commission=0.0003,\
                             close_today_commission=0, min_commission=5), type='stock')
    # 运行函数
    run_daily(trade, 'every_bar')

## 交易程序
def trade(context):
    security = g.security
    # 设定均线窗口长度
    n1 = 5
    n2 = 10
    # 获取股票的收盘价
    close_data = attribute_history(security, n2+2, '1d', ['close'],df=False)
    # 取得过去 ma_n1 天的平均价格
    ma_n1 = close_data['close'][-n1:].mean()
    # 取得过去 ma_n2 天的平均价格
    ma_n2 = close_data['close'][-n2:].mean()
    # 取得当前的现金
    cash = context.portfolio.cash

    # 如果当前有余额，并且n1日均线大于n2日均线
    if ma_n1 > ma_n2:
        # 用所有 cash 买入股票
        order_value(security, cash)
        # 记录这次买入
        log.info("Buying %s" % (security))

    # 如果n1日均线小于n2日均线，并且目前有头寸
    elif ma_n1 < ma_n2 and context.portfolio.positions[security].closeable_amount > 0:
        # 全部卖出
        order_target(security, 0)
        # 记录这次卖出
        log.info("Selling %s" % (security))

    # 绘制n1日均线价格
    record(ma_n1=ma_n1)
    # 绘制n2日均线价格
    record(ma_n2=ma_n2)
```

# 银行股轮动策略

```python
'''
始终持有沪深300银行指数成分股中市净率最低的股份制银行，每周检查一次，
如果发现有新的股份制银行市净率低于原有的股票，则予以换仓。
'''

## 初始化函数，设定要操作的股票、基准等等
def initialize(context):
    # 设定沪深300银行指数作为基准
    set_benchmark('399951.XSHE')
    # True为开启动态复权模式，使用真实价格交易
    set_option('use_real_price', True) 
    # 设定成交量比例
    set_option('order_volume_ratio', 1)
    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, \
                             open_commission=0.0003, close_commission=0.0003,\
                             close_today_commission=0, min_commission=5), type='stock')
    # 运行函数, 按周运行，在每周第一个交易日运行
    run_weekly(chenk_stocks, weekday=1, time='before_open') #选股
    run_weekly(trade, weekday=1, time='open') #交易

## 得到沪深300银行指数成分股,找到市净率最低的股票
def chenk_stocks(context):
    # 得到沪深300银行指数成分股
    g.stocks = get_index_stocks('399951.XSHE')

    # 查询股票的市净率，并按照市净率升序排序
    if len(g.stocks) > 0:
        g.df = get_fundamentals(
            query(
                valuation.code,
                valuation.pb_ratio
            ).filter(
                valuation.code.in_(g.stocks)
            ).order_by(
                valuation.pb_ratio.asc()
            )
        )

        # 找出最低市净率的一只股票
        g.code = g.df['code'][0]

## 交易
def trade(context):
    if len(g.stocks) > 0:
        code = g.code
        # 如持仓股票不是最低市净率的股票，则卖出
        for stock in context.portfolio.positions.keys():
            if stock != code:
                order_target(stock,0)
        
        # 持仓该股票
        if len(context.portfolio.positions) > 0:
            return
        else:
            order_value(code, context.portfolio.cash)
    
```

# 低估价值选股策略

```python
'''
1.市净率小于2；
2.负债比例高于市场平均值;
3.企业的流动资产至少是流动负债的1.2倍;
4.每年四次调仓，即在1/4/7/10月调仓；
5.可加入止损(十天HS300跌幅达10%清仓)；
'''

## 初始化函数，设定要操作的股票、基准等等
def initialize(context):
    # 设定指数
    g.stockindex = '000300.XSHG' 
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # True为开启动态复权模式，使用真实价格交易
    set_option('use_real_price', True) 
    # 设定成交量比例
    set_option('order_volume_ratio', 1)
    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, \
                             open_commission=0.0003, close_commission=0.0003,\
                             close_today_commission=0, min_commission=5), type='stock')
    # 最大持仓数量
    g.stocknum = 10

    ## 自动设定调仓月份（如需使用自动，注销下段）
    f = 4  # 调仓频率
    log.info(range(1,13,12/f))
    g.Transfer_date = range(1,13,12/f)
    
    ## 手动设定调仓月份（如需使用手动，注释掉上段）
    # g.Transfer_date = (3,9)
    
    #根据大盘止损，如不想加入大盘止损，注释下句即可
    # run_daily(dapan_stoploss, time='open') 
    
    ## 按月调用程序
    run_monthly(trade, monthday=20, time='open')

## 交易函数
def trade(context):
    # 获取当前月份
    months = context.current_dt.month
    # 如果当前月为交易月
    if months in g.Transfer_date:
        ## 获得Buylist
        Buylist = check_stocks(context)
        
        ## 卖出
        if len(context.portfolio.positions) > 0:
            for stock in context.portfolio.positions.keys():
                if stock not in Buylist:
                    order_target(stock, 0)

        ## 分配资金
        if len(context.portfolio.positions) < g.stocknum :
            Num = g.stocknum  - len(context.portfolio.positions)
            Cash = context.portfolio.cash/Num
        else: 
            Cash = 0

        ## 买入
        if len(Buylist) > 0:
            for stock in Buylist:
               if stock not in context.portfolio.positions.keys():
                   order_value(stock,Cash)
    else:
        return
    
## 选股函数
def check_stocks(context):
    # 获取沪深成分股
    security = get_index_stocks(g.stockindex)

    Stocks = get_fundamentals(query(
            valuation.code,
            valuation.pb_ratio,
            balance.total_assets,
            balance.total_liability,
            balance.total_current_assets,
            balance.total_current_liability
        ).filter(
            valuation.code.in_(security),
            valuation.pb_ratio < 2, #市净率低于2
            balance.total_current_assets/balance.total_current_liability > 1.2 #流动资产至少是流动负债的1.2倍
        ))
    
    # 计算股票的负债比例
    Stocks['Debt_Asset'] = Stocks['total_liability']/Stocks['total_assets']
    # 获取负债比率的市场均值
    me = Stocks['Debt_Asset'].median()
    # 获取满足上述条件的股票列表
    Codes = Stocks[Stocks['Debt_Asset'] > me].code

    return list(Codes)

## 根据局大盘止损，具体用法详见dp_stoploss函数说明
def dapan_stoploss(context):
    stoploss = dp_stoploss(kernel=2, n=3, zs=0.1)
    if stoploss:
        if len(context.portfolio.positions)>0:
            for stock in list(context.portfolio.positions.keys()):
                order_target(stock, 0)

## 大盘止损函数
def dp_stoploss(kernel=2, n=10, zs=0.03):
    '''
    方法1：当大盘N日均线(默认60日)与昨日收盘价构成“死叉”，则发出True信号
    方法2：当大盘N日内跌幅超过zs，则发出True信号
    '''
    # 止损方法1：根据大盘指数N日均线进行止损
    if kernel == 1:
        t = n+2
        hist = attribute_history('000300.XSHG', t, '1d', 'close', df=False)
        temp1 = sum(hist['close'][1:-1])/float(n)
        temp2 = sum(hist['close'][0:-2])/float(n)
        close1 = hist['close'][-1]
        close2 = hist['close'][-2]
        if (close2 > temp2) and (close1 < temp1):
            return True
        else:
            return False
    # 止损方法2：根据大盘指数跌幅进行止损
    elif kernel == 2:
        hist1 = attribute_history('000300.XSHG', n, '1d', 'close',df=False)
        if ((1-float(hist1['close'][-1]/hist1['close'][0])) >= zs):
            return True
        else:
            return False
```

# Dual_Thrust策略—股指期货

```python
'''
1、首先计算:
(1)N日High的最高价HH, N日Close的最低价LC;
(2)N日Close的最高价HC，N日Low的最低价LL;
(3)Range = Max(HH-LC,HC-LL)
(4)BuyLine = Open + K1*Range
(5)SellLine = Open + K2*Range

2.构造系统
(1)当价格向上突破上轨时，如果当时持有空仓，则先平仓，再开多仓；如果没有持仓，则直接开多仓；
(2)当价格向下突破下轨时，如果当时持有多仓，则先平仓，再开空仓；如果没有持仓，则直接开空仓；
'''

def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # True为开启动态复权模式，使用真实价格交易
    set_option('use_real_price', True) 
    # 设定成交量比例
    set_option('order_volume_ratio', 1)
    # 关闭订单提醒
    # log.set_level('order', 'error')
    # 设定期货保证金比例
    set_option('futures_margin_rate', 0.3)
    # 设定操作金融期货
    set_subportfolios([SubPortfolioConfig(cash=context.portfolio.cash, type='index_futures')])
    # 金融期货close_today_commission可不用设定，平今仓默认0.0023
    set_order_cost(OrderCost(open_commission=0.000023, close_commission=0.000023, close_today_commission=0.0023), type='index_futures')
    #运行函数
    run_daily(set_info, time='before_open', reference_security='IF1512.CCFX')
    run_daily(trade, time='every_bar', reference_security='IF1512.CCFX')

def set_info(context):
    # 分钟计数
    g.minute_count = 0

def trade(context):
    # 开盘第一分钟
    if g.minute_count == 0:
        # 获取当月可交易的 HS300 股指期货合约
        g.security = get_stock_index_futrue_code(context,symbol='IF',month='current_month')
        # 获取 BuyLine, SellLine
        g.BuyLine, g.SellLine = dual_thrust(g.security,n=10,K1=0.5,K2=0.5)
        # 分钟计数
        g.minute_count += 1
    # 开盘第一分钟之后
    else:
        # 获取标的可平多仓
        long_closeable_amount = context.portfolio.long_positions[g.security].closeable_amount
        # 获取标的可平空仓
        short_closeable_amount = context.portfolio.short_positions[g.security].closeable_amount
        # 获取标的的最新价
        current_price = attribute_history(g.security, 1, '1m', ['close'], df=False)['close'][0]

        # 当价格向上突破上轨时
        if current_price > g.BuyLine:
            # 如果当时持有空仓，则先平仓，再开多仓；
            if(short_closeable_amount>0):
                # 平空仓
                order_target(g.security, 0 , side='short')
                # 开1手多仓
                order(g.security, 1, side='long')
                log.info('持有空仓，先平仓，再开多仓')
            # 如果没有持仓，则直接开多仓；
            elif (short_closeable_amount == 0) and (long_closeable_amount == 0):
                # 开1手多仓
                order(g.security, 1, side='long')
                log.info('没有持仓，开多仓')
        # 当价格向下突破下轨时
        elif current_price < g.SellLine:
            # 如果当时持有多仓，则先平仓，再开空仓；
            if (long_closeable_amount>0):
                # 平多仓
                order_target(g.security, 0 , side='long')
                # 开1手空仓
                order(g.security, 1, side='short')
                log.info('持有多仓，先平仓，再开空仓')
            # 如果没有持仓，则直接开空仓；
            elif (short_closeable_amount == 0) and (long_closeable_amount == 0):
                # 开1手空仓
                order(g.security, 1, side='short')
                log.info('没有持仓，则直接开空仓')

        # 分钟计数
        g.minute_count += 1

## 获取 BuyLine 和 SellLine
def dual_thrust(security,n,K1,K2):
    hist = attribute_history(security, n, '1d', ['high','low','close','open'], df=False)
    HH = max(hist['high'])
    LC = min(hist['close'])
    HC = max(hist['close'])
    LL = min(hist['low'])
    Open = get_current_data()[security].day_open
    # 获取 Range
    Range = max((HH-LC),(HC-LL))
    # 计算BuyLine 和 SellLine
    
    BuyLine = Open + K1 * Range
    SellLine = Open - K2 * Range
    # 返回结果
    return BuyLine, SellLine

## 获取当天时间正在交易的股指期货合约
def get_stock_index_futrue_code(context,symbol,month='current_month'):
    '''
    获取当天时间正在交易的股指期货合约。其中:
    symbol:
            'IF' #沪深300指数期货
            'IC' #中证500股指期货
            'IH' #上证50股指期货
    month:
            'current_month' #当月
            'next_month'    #隔月
            'next_quarter'  #下季
            'skip_quarter'  #隔季
    '''
    display_name_dict = {'IF':'沪深300指数期货','IC':'中证500股指期货','IH':'上证50股指期货'}
    month_dict = {'current_month':0, 'next_month':1, 'next_quarter':2, 'skip_quarter':3}

    display_name = display_name_dict[symbol]
    n = month_dict[month]
    dt = context.current_dt.date()
    a = get_all_securities(types=['futures'], date=dt)
    try:
        df = a[(a.display_name == display_name) & (a.start_date <= dt) & (a.end_date >= dt)]
        if (len(df)>4) and (month in ('next_quarter','skip_quarter')):
            return df.index[n+1]
        else:
            return df.index[n]
    except:
        return 'WARRING: 无此合约'

# 获取金融期货合约到期日
def get_CCFX_end_date(fature_code):
    return get_security_info(fature_code).end_date
```