## 数组

### [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)

- 动态规划

  每一阶的计算方法类似于斐波那契，是典型的动态规划

- 递归

  直接做递归其实很简单，但是某些数值会被重复计算很多次，因此难点就在于如何不重复计算，这里我们通过维护一个数组用于记录每一阶的结果，等到要调用的时候判断如果数组中已经有值了就直接从数组中取值，如果没有就去计算，这样可以将计算量降低一个数量级

- 另外还可以通过矩阵快速幂优化斐波那契的计算过程（事实上就是矩阵运算的化简），最终得到一个方程式来进行编程求解
- 另外还可以通过斐波那契的计算公式（可以通过特征值求解方程可行解得到）来进行求解

### [88. Merge Sorted Array](https://leetcode-cn.com/problems/merge-sorted-array/)

利用其中一个数组的多余空间合并两个数组

- 直接将第二个数组加到第一个数组的后面，最后调用sort()进行排序
- 双指针/从前往后
  - 需要开辟一个新数组，由于给定的两个数组已经经过排序，因此从头比较原先两个数组的元素大小，较小的那个插入新数组，等到两个数组中的某一个数组的指针走到了尾部，就将剩余没走完的数组的剩余所有元素加到新数组后面即可

- 双指针/从后往前
  - 由于给定的第一个数组有足够多的空余位置可以存放第二个数组，因此我们完全不需要开辟一个新数组，只需要从后往前比较并将较大的那个插入第一个数组最后面的空余位置即可（这需要我们将用于插入的指针从最开始就指向第一个数组最后，每次插入后就像前移动一格）
  - 这样做有一个好处就是：因为给定的两个数组都已经排好序了，如果第二个数组走完，那第一个数组的剩余元素天然的就存在第一个数组的前面，且不需要再去排序；如果第一个数组先走完，那也没关系，第二个数组的剩余元素还是可以正常的插入到第一个数组前面（那是因为我们可以保证在第二个数组走完之前第一个数组的用于插入的指针永远不会走到底，那是因为给定的第一个数组拥有足够的空间存放两个数组的所有元素）
  - 扩展：其实这么想的话就算第一个数组没给足够的空间，我们也可以resize他，让他拥有存放两个数组所有元素的足够的空间，然后用双指针从后往前的方法去做

### [118. Pascal's Triangle](https://leetcode-cn.com/problems/pascals-triangle/)

- 动态规划

  每一列都是通过上一列得来的，这是典型的动态规划

### [119. Pascal's Triangle II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

- 动态规划

  总的来说就是利用杨辉三角后一行与前一行的关系
  更新过程为：从倒数第二个元素开始往前更新它等于原来这个位置的数 + 前一个位置的数
  行[i] = 行[i] + 行[i-1]

  - 方法一

    在当前数组的后面加新的数，最后把前面原来的数擦除

  - 方法二

    每一次遍历先向数组最后添加 1 ，再执行：行[i] = 行[i] + 行[i-1] 这个逻辑

### [121. Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

- 暴力法

- 一次遍历

  如果以卖出的那一天为基准，这样的话买入价格一定是越低越好，当然这个买入的日子一定是在卖出之前；如果以买入的那一天为基准，由于不知道后面哪一天价格最低，因此我们就把当天的价格当成最低的，向后计算后面每一天的收益，记录最大收益，当遇到某一天的买入价格比之前的价格低的时候（想一下后面不管价格是多少，我们都应该选择价格更低的那个价格，这样收益一定是最大的），我们应该修改买入价格为这一天的价格。这样的话到最后所记录的最大收益就是最大收益了

### [122. Best Time to Buy and Sell Stock II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

- 暴力法
  - 把每一波都当成是最优的购入，之后去找比购入价格大的那一天卖出，再从卖出的后一天开始买入（这一天还是被当成最优）（用递归实现后续的买入和卖出）
  - 计算每次卖出后卖出价格 - 买入价格 + 后续的每一次买入和卖出的价格差（递归）
  - 保存每一天作为买入时的收益，取最大值即为最大收益
  - 该算法时间复杂度极大

- 峰谷法
  - 理论上每一次谷的时候买入，峰的时候卖出（这里的谷和峰可以类比函数一阶导为0的点），这样的收益一定比整个函数最峰 - 最谷的价格收益大
  - 因此先找到函数的波谷，再在波谷之后找波峰，再在波峰之后找波谷，再找波峰...
  - 将每一次的峰谷价格差累加，即为最优收益

- 一次遍历
  - 思路还是上面的峰谷法，但这次我们不再寻找波峰和波谷
  - 理论上如果函数一直上升的话到某一个波峰的时候他的总收益（波峰 - 波谷）是等于每一段上升的价格累计之和，因此我们只需要累加上升的价格，跳过下降的价格即可得到最优收益

### [136. Single Number](https://leetcode-cn.com/problems/single-number/)

首先明确数组中的元素只会出现两次或一次，且出现一次的元素只有一个

- 可以将数组元素放入集合中，再计算集合中元素之和乘以2，再减去数组元素之和即可得到结果

- 维护一个集合，如果集合中没有该元素就加入，如果有了就去除，最后剩下的就是结果

- 用哈希表存储每个元素及其出现的次数，最后遍历得到出现一次的元素

- 位运算

  上述方法都需要开辟额外的空间，其实本质上我们就是想得到这样的效果：如果有两个一样的元素就把他拼掉，那异或运算正好符合这个操作，因此对数组中每一个元素都做一次异或操作即可得到结果

### [167. Two Sum II - Input array is sorted](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

- 暴力枚举法

  对每一个元素，从他后面的位置挨个遍历找另一个元素

- 二分查找法

  思路还是暴力枚举的思路，差别在于由于给定的数组有序，因此在查找另一个元素的时候可以用二分查找法

- 双指针

  由于给定数组有序，因此采用头尾指针，如果指向元素之和小于目标值，就将头指针向后移，反之尾指针向前移，直到找到元素

## 树

### [101. Symmetric Tree](https://leetcode-cn.com/problems/symmetric-tree/)

- 镜像
  - 难点在于构造一个函数：isSymmetric(left, right)；在这个函数中对比left和right两棵树是否对称（结构一样，同一位置的结点值一样），具体做法可以是在函数中维护一个queue，每次push到这个队列的两棵树都是同一位置的（位置对称），这样每次从队列弹出的两棵树就是位置对称的，再进行比较即可
  - 在主函数中调用上述函数：isSymmetric(root, root)；这就是镜像的技巧了，将root当作左右两棵树传入即可得知他是否对称

- 递归

  从树的根结点开始自上向下判断（位置对称的结点值是否相等）

  - 难点在于构造一个函数，该函数能比较从总体上来看的整棵树的每一个对称的部位（意思就是两个结点或者说两棵树相距甚远，但他们是在总体上来看的整棵树的对称的两个部位）具体代码：<font color="green">**return left->val == right->val && check(left->left, right->right) && check(left->right, right->left);**</font>
  - 另一个技巧是异或运算符（^）的应用，由于左右必须对称，因此左边和右边只要状态不一样就返回false，具体代码：<font color="green">**if(left == nullptr ^ right == nullptr) return false;**</font>

- 递归+镜像
  
  - 本质上就是将上述的两种方法结合的一种方法，只不过是在上述递归的基础上调用函数时由原先的function(root->left, root->right)变为function(root, root)，当然函数内部的一些细节还需要进行一些修改

### [107. Binary Tree Level Order Traversal II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

- 迭代，可以选择对树的每一层做一个for循环遍历
- 递归，用pair结构记录每一层的结点及其高度从而判断是否要向数组头部插入新数组，之后再向数组头部的数组添加元素，然后左右子树递归

### [110. Balanced Binary Tree](https://leetcode-cn.com/problems/balanced-binary-tree/)

- 自顶向下递归，关键在于写出一个计算高度的函数，利用这个函数计算左右子树的高度之后计算两树高度差从而做出判断，并递归判断子树的子树

- 自底向上递归，关键点：
  - 后序遍历的实现（也就是先来子树，后来自己）（其实主要就是代码顺序的问题）
  - 写出计算高度的函数
  - 自底向上地判断两棵子树的高度差，如果超过1，则显然不是平衡二叉树，因此返回-1（这里注意-1的判断条件，应该是子树先判断，如果子树都是-1了，那就不需要其他判断了，结果一定是-1），否则返回自身高度（子树最大高度 + 1）

### [111. Minimum Depth of Binary Tree](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

- 深度优先
  - 难点在于维护一个全局的最小高度（其实就是每次递归下去都返回当前高度与全局最小高度的最小值即可）
- 广度优先
  - 难点在于动态保存迭代过程中每一个结点本身及其高度（这里用一个pair结构实现）
  - 维护一个queue，每次都取出队列中的结点，如果他没有子树了，就返回其高度，否则就向队列中添加pair（子树及其自身（是当前结点自身，不是当前结点的子树）的高度 + 1）

### [112. Path Sum](https://leetcode-cn.com/problems/path-sum/)

- 递归
  - 技巧在于每一次递归都将总合sum减去当前结点的值，并将减去之后的值传入函数自顶向下递归，最后如果是符合题意的一棵树，那减到最后的值必定会等于某一个叶子结点的值

- 迭代
  - 技巧在于每次迭代都保存该结点的上层结点的值
  - 维护两个队列，一个用于保存结点，另一个用于保存该结点的值
  - 最后的判定条件为计算分支走到叶子结点的时候用于保存值的队列中的相应位置的值与该叶子结点的值之和，只要有一个分支通过这样的计算之后的值等于总合sum那就是符合题意的一棵树

## 字符串

### [125. Valid Palindrome](https://leetcode-cn.com/problems/valid-palindrome/)

- 先去除非数字字母的字符，最后reverse()对比两个字符串是否相等
- 双指针
  - 先去除非数字字母的字符，然后双指针一个从前往后，一个从后往前比较字符是否相等
  - 直接比较前后对称字符是否相等，遇到非数字字母的字符就跳过

### [171. Excel Sheet Column Number](https://leetcode-cn.com/problems/excel-sheet-column-number/)

- 26进制加减乘除法

### [168. Excel Sheet Column Title](https://leetcode-cn.com/problems/excel-sheet-column-title/)

需要注意的是excel中的A-Z是1-26，不是0-25

- 26进制加减乘除法

  - 对26特殊处理

    其他数字照常取余，唯独26取余之后变0，因此26特殊处理让他直接变“Z”，此外26 / 26 = 1，这个1其实是多余的，因此在传入的数字是26的倍数的时候除了上述的特殊处理，还需要将该数减1（这对于后续是没有影响的，因为在后续做进位的时候会把上一位的剩余部分舍弃掉）

  - 直接将1-26映射到0-25

    假设传入的数为n，在运算之前直接做一步n--即可，这样还省去了对26特殊处理这一步操作

### [毕导密码破解](https://www.bilibili.com/video/BV1Wv411y7UA?t=132)

首先文本中的每一个字母都向右平移了若干个字母，已知正常情况下英文语句中 a-z 每个字母出现的频率，要求破解密文

- 暴力枚举

  遍历不同平移长度，每一次都统计字母词频，与已知字母词频做残差平方和运算，找到结果最小的那一次平移的位数，再将原文本向左平移该位数长度即可破解密文

## 链表

### [141. Linked List Cycle](https://leetcode-cn.com/problems/linked-list-cycle/)

- 将链表结点放入集合中，如果遍历到相同元素，则说明有环

- 快慢指针（弗洛伊德判圈算法）

  慢指针一次走一步，快指针一次走两步，如果快指针探到底了，说明不是环，如果快慢指针相遇了，则说明有环

### [160. Intersection of Two Linked Lists](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

- 对A链表的每一个结点，遍历B链表，检查B链表是否存在与A链表中某个结点相同的结点

- 将A链表结点放入集合，遍历B链表，检查B链表是否存在已经在集合中的结点

- 双指针法

  创建pA和pB，分别指向链表A和B，让他们向后遍历，如果pA遍历完了，就让pA指向B链表，如果pB遍历完了，就让pB指向A链表，再继续向后遍历，此时如果有交点，则pA和pB一定能一起遍历到该交点。原理其实很简单，只要让两个指针在交点之前走过一样的长度即可，该长度就是两个链表交点之前的结点数量之和

## 栈

### [155. Min Stack](https://leetcode-cn.com/problems/min-stack/)

- 重点在于获取栈中最小值的算法的实现

  事实上只需要维护两个栈s1、s2，s1用于存放真正的数据，s2用于存放每次push的时候push的值与上一次push时s1中元素最小的值对比之后的较小值，相当于存放了每一层的最小值，这样就算执行pop操作，s2pop的还是这一层的最小值，这样的话在获取s2.top()的时候获取的值始终会是当前s1中元素的最小值

## 阶乘

### [172. Factorial Trailing Zeroes](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

- 暴力法

  直接将n!算出后计算0的个数

  - 时间复杂度计算

    计算阶乘是重复的乘法。通常，当我们知道乘法是固定大小的数字上（例如 32 位或 64 位整数）时，我们可以视为 O(1)运算。但是，这里要乘以的数字会随着 n 大小而增长，所以这里不能这么做。

    因此，这里的第一步是考虑乘法的成本，因为我们不能假设它是 O(1)，这里的时间复杂度计算需要记忆：O((log x) · (log y))

    接下来，我们考虑以下在计算 n!n! 时，我们做了什么乘法运算。前几个乘法如下：

    1⋅2=2
    2⋅3=6
    6⋅4=24
    24⋅5=120
    120⋅6=720
    ......

    这些乘法的成本：

    log1⋅log2
    log2⋅log3
    log6⋅log4
    log24⋅log5
    log120⋅log6
    ......

    我们可以改写为：

    log 1!⋅log 2
    log 2!⋅log 3
    log 3!⋅log 4
    log 4!⋅log 5
    log 5!⋅log 6
    ......

    每行的格式为 (log*k*!)⋅(log*k*+1)，最后一行是log((*n*−1)!)⋅log(*n*)

    我们一个接一个地做这些乘法运算，并把它们相加，得到总的时间复杂度：

    log1!⋅log2+log2!⋅log3+log3!⋅log4+⋯+log((n−2)!)⋅log(n−1)+log((n−1)!)⋅logn

    从这个公式来看，我们会发现时间复杂度比 O(n) 差。

    接下来扔掉不太重要的项：

    注意 log((n−1)!) 比 log n 大的多。因此，我们将删除这部分，留下 log((n−1)!)：

    log1!+log2!+log3!+⋯+log((n−2)!)+log((n−1)!)

    继续化简：

    记住重要公式：***O*(log *n*!)=*O*(*n*log *n*)**

    根据该公式我们可以得到：

    1⋅log1+2⋅log2+3⋅log3+⋯+(n−2)⋅log(n−2)+(n−1)⋅log(n−1)

    去掉较小项：

    1+2+3+...+(*n*−2)+(*n*−1)

    即得时间复杂度为 *O*(*n*2)

    这个复杂度太大了，而且丢弃了项以后会使我们的时间复杂度低于真实的时间复杂度

  - 空间复杂度计算

    为了存储 n!，我们需要 O(logn!) 位，而它等于 O(nlogn)，因此空间复杂度：O(logn!)=O(nlogn)


- 因子分解

  数字最后的0是由10来的，而10可以分解为2和5，而将数分解为2的概率要高于5，那是因为10以内4和8都可以分解为多个2，而只有10可以分解为多个5，因此肯定是2的数量比较多，而我们必须需要一对2和5才能凑出一个10，因此直接找分解后5的个数即可

  注意，这里我们不需要遍历全部的数，只需要遍历是5的倍数的数，因为只有是5的倍数的数才能分解出5这个因子

  - 时间复杂度

    每五个数字处理一次，因此是O(n / 5)，即O(n)

    遇到25、125这种的需要将该数字循环除以5来处理，因此是O(log5 n)，由于绝大部分数都只能分解出一个5，可以证明，因子 5 的总数小于 2 · n / 5，因此事实上他只消耗O(1)

    综合来看时间复杂度就是O(1) * O(n) = O(n)

  - 空间复杂度

    由于只用了一个整数变量，因此空间复杂度为：O(1)

- 高效计算因子5

  上述第二种方法精华在于找到阶乘起来的数能分解出多少个5，事实上，要是以这个为目的的话我们根本不需要遍历，直接从n本身就可以推断出有多少个5

  试想一下，如果n是25，那么理论上 1 - 25 这几个数里面能分解出5的有25 / 5 = 5个数，但是仅仅之这样还不够，因为25本身就能分解出两个5，也就是说会有多重因子的数字存在，那么如何解决这个问题呢？其实只需要找到所有重因子的数（包括2重、3重、...）,并加上那些没有被算上去的其他重因子5的个数即可，那么如何去找到这些重因子呢？以125为例，首先去找125中重数最小的因子，也就是二重，也就是25的倍数，分别是25、50、75、100、125，这些都是能分解出两个5的，再去找三重，也就是125的倍数，那就是125本身，再找四重就没有了，然后开始加和，首先加上一重的，也就是5的倍数，125 / 5 = 25（注意这里会把二重、三重的数加一遍，所以一会儿加二重或者三重的数的时候就不必重复加了），再加上二重的，125 / （5 * 5） = 5（同理，这里会把三重的数加一遍，一会儿加三重的数的时候也不用再重复加了），最后加三重的数，125 / （5 * 5 * 5） = 1（还是解释一下这里为什么明明125能分解为5 * 5 * 5但却记为1而不是3，因为在计算二重和一重的时候，已经把5 * 5 * 5中的前面两个5算进去了，所以就不需要重复计数了，因此记为1就可以），至此，停止结束，加和即为：25 + 5 + 1 = 31

  总结一下上述计算过程，拿25为例其实就是：

  ```python
  fives = n / 5 + n / 25
  tens = fives
  ```

  拿125为例：

  ```python
  fives = n / 5 + n / 25 + n / 125
  tens = fives
  ```

  - 时间复杂度

    在该方法中，我们将n除以5的每个幂，相当于O(log5 n)，由于乘除法在32位整数范围内，我们将这些计算视为O(1)，因此O(1) * O(log5 n) = O(log5 n) ~ O(log n)

  - 空间复杂度

    由于使用了常数空间，因此空间复杂度为：O(1)

## SQL

### [176. Second Highest Salary](https://leetcode-cn.com/problems/second-highest-salary/)

- 注意去重
- 注意有可能不存在排名第二的数值
  - 因此可以将第一层用于搜索的select作为临时表，外面再套一层select
  - 也可以在上面的基础上配合IFNULL函数来处理NULL的情况

### [181. Employees Earning More Than Their Managers](https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/)

联表查询，语法可以用sql92的也可以用sql99的

### [183. Customers Who Never Order](https://leetcode-cn.com/problems/customers-who-never-order/)

- 可以用NOT IN筛选Customers的id没有在Orders的外键CustomerId中的Customers的name
- 也可以用left outer join 筛选联表后CustomerId为NULL的Customers的name

### [196. Delete Duplicate Emails](https://leetcode-cn.com/problems/delete-duplicate-emails/)

- 借助子查询查找Email重复的id，需要注意的是需要在子查询的临时表外面再套一层select，否则可能会出现同时查询和更新表的错误

  - 附上代码

    ```mysql
    DELETE FROM Person 
    WHERE id in (
    	SELECT id FROM (
        	SELECT id FROM Person p1 LEFT OUTER JOIN Person p2 
            ON p1.Email=p2.Email
            WHERE p1.id > p2.id
        ) temp
    );
    ```

- 可以使用delete 要删除的表 from ... 的语法

  - 注意，这个语法sql92和sql99都有

  - 附上代码

    ```mysql
    DELETE p1 FROM Person p1, Person p2 
    WHERE p1.Email=p2.Email
    AND p1.id > p2.id;
    ```

### [197. Rising Temperature](https://leetcode-cn.com/problems/rising-temperature/)

利用DATEDIFF函数

- 可以使用子查询，通过对比今天和昨天的温度得到答案

- 可以使用join，合并的关联字段是今天的日期和昨天的日期，事实上就是这样写：

  ```mysql
  ON DATEDIFF(today.date, yesterday.date)=1
  ```

  之后再比较今日和昨日的温度得到答案

## 位操作

### [190. Reverse Bits](https://leetcode-cn.com/problems/reverse-bits/)

- 与操作配合位操作

  二进制数跟1的与操作可以知道二进制数的最右位，再将该位左移至最左位，再找到最右边第二位，左移至最左边第二位，循环此操作即可

- 带记忆化的按字节（8位）颠倒

  ![在这里插入图片描述](https://pic.leetcode-cn.com/365599a4030d26a019d37ad97c201e64e2fa3ae9fd7b43d689e8a4d7f802141e-file_1585801736122)

  在处理长字节流时，每字节（8 位的比特位）反转可能更有效，但是本题输入的是固定的 32 位整数，所以字节颠倒可能更有效

  - 附上按自己为单位反转位的算法：

    ```python
    # 这个算法是用 3 个操作反转一个字节中的位，在 Sean Eron Anderson 的在线电子书 Bit Twiddling Hacks 中可以看到更多的细节。
    def reverseByte(byte):
        return (byte * 0x0202020202 & 0x010884422010) % 1023
    ```

    上述算法完全基于算术和位操作，不涉及循环

  - 可以缓存先前计算的值，以避免重新计算

  - 步骤

    - 按字节遍历整数（总共32位，每次取最右边的8位，每次操作完后都将该整数右移8位）这里我们使用位掩码为 `11111111` 的与操作（即 `n&0xff`）来完成该操作
    - 之后使用上述的reverseByte()方法来反转字节中的位，获取每个字节（8位）反转后的字节，注意，这里我们维护一个map来保存每一次的计算，下次如果有重复的计算就直接使用map中的结果即可可以减少计算量
    - 之后将该反转后的字节左移24（32 - 8 = 24， 当然第二次的话就是 24 - 8 = 16，以此类推）
    - 等到所有位都做了上述操作之后，我们就得到反转之后的结果了。当然，这里我们选择了8位，也可以选择4位，或更小的位数，这将需要更多的计算来交换更少的缓存空间

- 分治策略颠倒位的顺序

  上面的带记忆化的按字节颠倒方法将整数按照字节分成若干份，再循环处理最后得到结果，那能不能在不使用循环的情况下反转整个32位呢？事实上我们可以将32分成16，16分成8，8分成4，...，直到最后分成块数为1位为止，并将每个块反转合并最后得到结果。通俗来讲就是把32劈成两半，反转，再把左边右边的16各自劈成两半，反转，...，最后粒度到1为止，反转，即可

  - 这里控制取到数的前一半位和后一半位的方法其实就是一个与操作

  - 将两部分数合到一起其实就是一个位操作配合一个或操作

  - 附上代码：

    ```c++
    class Solution {
    public:
        uint32_t reverseBits(uint32_t n) {
            n = (n >> 16) | (n << 16);
            n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);
            n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);
            n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);
            n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);
            return n;
        }
    };
    ```

### [191. Number of 1 Bits](https://leetcode-cn.com/problems/number-of-1-bits/)

- 让数右移并跟 1 做与运算来判断每一次右移之后最右边的是否是1，并进行计数

- 二进制数消一法

  让数减一之后与数本身做与运算，循环操作后到某一次该数变为0，记录操作的次数即为二进制数中1的个数

  - 事实上上述操作每一次都会使得二进制数消掉最靠右的那个1

## Linux

### [193. Valid Phone Numbers](https://leetcode-cn.com/problems/valid-phone-numbers/)

- 使用grep，注意grep -P中的-P的意思是使用perl的正则表达式语法，perl的正则功能更强大

- 也可以使用awk或gawk，这是Unix上的grep

### [195. Tenth Line](https://leetcode-cn.com/problems/tenth-line/)

输出文件第十行文本方法：

- sed -n
- grep -n配合cut
- ...

统计文本行数方法：

- wc -l
- grep -nc "" file.txt
- grep -c "" file.txt
- grep -vc "^$" file.txt
- ...

