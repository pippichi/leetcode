# 类型

<span style="font-weight:bold">整型家族：</span>

- char
  - unsigned char
  - signed char

- short
  - unsigned short或unsigned short int
  - signed short或signed short int

- int
  - unsigned int
  - signed int

- long
  - unsigned long或unsigned long int
  - signed long或signed long int

<span style="font-weight:bold">浮点型家族：</span>

- float
- double

<span style="font-weight:bold">构造类型（自定义类型）：</span>

- 数组类型

  int [10]，int[5]，char [5]这些都是不同的数组类型

- 结构体类型 struct

- 枚举类型 enum

- 联合类型 union

<span style="font-weight:bold">指针类型：</span>

int* p，char* p，void* p等

<span style="font-weight:bold">空类型：</span>

void表示空类型（无类型）

通常应用于函数的返回类型、函数的参数、指针类型

举例：

```c
void test(){
    printf("ok\n");
}
int main(){
    test(100); // 正常输出ok，虽然这里传了个100过去，而test函数并没有形参去接它，但是函数依然没有报错，正常执行了。这是c语言比较模棱两可的地方。
    return 0;
}
```

那么对于上面这种函数，显然它不需要接收任何参数，那么我们可以这样写：

```c
void test(void){ // 后面那个void意思是我这个函数它是不需要参数的
    printf("ok\n");
}
int main(){
    test(100); // 这个时候如果还传个100过去，那编译器就会报警告了
    return 0;
}
```



## 类型的意义

- 使用类型开辟内存空间的大小（大小决定使用范围）
- 如何看待内存空间的视角（比方说int和float，明明都是4字节的，内存中存储的方式却不一样，那是因为一个是int一个是float）



# 大小端（解释整型数存储到内存时有时候是按字节倒着存的现象）

现象：

```c
int b = -10; // 那么b在内存中它很可能是存了个：0xf6ffffff
// 解释：b的原码、反码、补码：
// 10000000000000000000000000001010 - 原码
// 11111111111111111111111111110101 - 反码
// 11111111111111111111111111110110 - 补码
// 补码十六进制：0xfffffff6
// 而在内存中它是按照字节倒着存的，所以变成了：0xf6ffffff
```



<span style="font-weight:bold">什么是大端小端：</span>

> 大端（存储）模式（也被称为大端字节序存储模式），是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
>
> 小端（存储）模式（也被称为小端字节序存储模式），是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。

```c
// 比方说有数：0x11223344这样一个数
// 那在内存中可以这样存：11 22 33 44，也可以这样存：44 33 22 11，当然也可以这样存：11 33 22 44，存的方法有千千万万种，但是最人性化的也就两种：11 22 33 44 和 44 33 22 11。这两种模式分别叫大端模式和小端模式
```

![image-20210305172029330](c语言进阶.assets/image-20210305172029330.png)

为什么说11 22 33 44是属于大端模式呢？因为在十进制中我们按照万千百十个这样的顺序的话，万是属于高位的，个是属于低位的，那么十六进制也是一样，11 22 33 44中11是属于高位的，44是属于低位的，因为高位存在低地址，11 22 33 44被称为大端模式，同理44 33 22 11则被称为小端模式

所以我们上面的0xfffffff6以f6ffffff的形式存储在内存中，那显然就是小端模式了



<span style="font-weight:bold">为什么会有大小端模式之分呢？</span>

因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit，但是c语言中除了8bit的char之外，还有16bit的short，32bit的long（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在存储时如何安排多个字节的存储顺序的问题，因此就导致了大端存储模式和小端存储模式。



写程序判断当前机器是大端还是小端：

```c
int check_sys(){
    int a = 1;
    // 返回1，小端
    // 返回0，大端
    return *(char*)&a;
}
```



# 有符号数和无符号数所能表示的范围

拿char来举例

![image-20210307155551394](c语言进阶.assets/image-20210307155551394.png)

- 有符号数

  | 二进制补码 |                          二进制原码                          |                十进制                |
  | :--------: | :----------------------------------------------------------: | :----------------------------------: |
  |  00000000  |                           00000000                           |                  0                   |
  |  00000001  |                           00000001                           |                  1                   |
  |  00000010  |                           00000010                           |                  2                   |
  |    ...     |                             ...                              |                 ...                  |
  |  01111110  |                           01111110                           |                 126                  |
  |  01111111  |                           01111111                           |                 127                  |
  |  10000000  | 这个数比较特殊，我们在求原码的时候发现减一没地方去减了。那么在这里，我们直接将这个数定义为-128。其实定义成-128也是有一定道理的，假设使用9位二进制数来表示-128，那一定是110000000，那么它的反码是101111111，那么它的补码是110000000，我们发现补码的低8个比特位就是10000000 | <span style="color:red;">-128</span> |
  |  10000001  |                           11111111                           |                 -127                 |
  |  10000010  |                           11111110                           |                 -126                 |
  |    ...     |                             ...                              |                 ...                  |
  |  11111101  |                           10000011                           |                  -3                  |
  |  11111110  |                           10000010                           |                  -2                  |
  |  11111111  |                           10000001                           |                  -1                  |

  因此有符号的char的范围是：-128 -> 127

- 无符号数

  无符号的char那很简单，没有符号位了，因此能表示的范围是：00000000 -> 11111111，也就是0 -> 255

同理int、short、long等其他整型

案例1：

```c
int main(){
    char a = -128;
    char b = 128;
    printf("%u\n", a); // 4294967168
    printf("%u\n", b); // 4294967168
    return 0;
}
```

案例2：

```c
unsigned int a = 0; // 00000000000000000000000000000000
a -= 1; // 11111111111111111111111111111111
printf("%u\n", a); // 由于是无符号数，因此输出为4294967295（11111111111111111111111111111111）
```

案例2变种：

```c
unsigned int i;
for(i = 9; i >= 0; i--){
    printf("%u\n", i);
}
// 结果就是死循环
```

案例3：

```c
int main(){
    char a[1000];
    int i;
    for(i = 0; i < 1000; i++){
        a[i] = -1 - i; 
    }
    printf("%d\n", strlen(a)); // 128 + 127 = 255
    return 0;
}
// 解释：11111111, 11111110, 11111101, ..., 10000000, 01111111, 01111110, ..., 00000000, 11111111, 11111110, ...
// 记住一点，char型永远都是截取比特位最后8位，如果进位那也是截取比特位最后8位，如果00000000减一不够减的时候向第9位借位之后还是会截取比特位最后8位，因此00000000减一就变成11111111
```

# limits.h和float.h

limits.h用于找到整型数的取值范围

float.h用于找到浮点型数的取值范围

# 浮点数在内存中的存储

根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式：

> - (-1)^S * M * 2^E
> - (-1)^S表示符号位，S=0时V为正数；S=1时V为负数
> - M表示有效数字，大于等于1，小于2.（为什么是大于等于1，小于2呢？首先科学计数法有效数字肯定是大于等于1的，然后这里是二进制所以只有1或0，因此有效数字小于2）
> - 2^E表示指数位

举例来说：

十进制的5.0，写成二进制是101.0，相当于(-1)^0 * 1.01 * 2^2。那么，按照上面V的格式，可以得出S=0，M=1.01，E=2。

十进制的-5.0，写成二进制是-101.0，相当于(-1)^1 * 1.01 * 2^2。那么，按照上面V的格式，可以得出S=1，M=1.01，E=2。



那么浮点数在内存中到底是怎么存储的呢？

![image-20210307202642547](c语言进阶.assets/image-20210307202642547.png)

![image-20210307202935460](c语言进阶.assets/image-20210307202935460.png)

<span style="font-weight:bold;">IEEE 754对有效数字M和制数E，还有一些特别规定。</span>前面说过，1≤M＜2，也就是说，M可以写成1.xxxxxxx的形式，其中xxxxxx表示小数部分。

IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。

<span style="color:red;">注意！对于M来讲，如果M没有满23位数字，则需要向后补0直到补满23位数字为止。</span>

<span style="font-weight:bold;">至于指数E，情况就比较复杂。</span>

<span style="font-weight:bold;">首先，E为一个无符号整数（unsigned int）。</span>这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047.但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023.比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

比方说：

十进制的0.5，写成二进制是0.1（二进制中小数点后面的那个1表示2^(-1)），相当于(-1)^0 * 1.0 * 2^(-1)，我们发现，E此时是-1，是个负数，但是我们知道内存中存E的地方是需要存无符号数的，那么这里怎么办呢？这里采取的方法是加一个中间数（对于8位的E，这个中间数是127；对于11位的E，中间数是1023），加上之后，E就算原先是负数，现在也变正数了，就可以存到内存中存E的地方了

<span style="color:red;">注意！对于E来讲，不管它是正数还是负数，都要加中间数。</span>

举例：

```c
float f = 5.5;
// 5.5
// 101.1
// (-1)^0 * 1.011 * 2^2
// S = 0
// M = 1.011
// E = 2 （E此时还需要加上127，也就是说E最后存进去的是2 + 127 = 129 -> 10000001）
// 0 10000001 011 00000000000000000000 -> 0100 0000 1011 0000 0000 0000 0000 0000
// 0x40b00000
```

